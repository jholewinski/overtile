
#include "overtile/OpenCLBackEnd.h"
#include "overtile/Expressions.h"
#include "overtile/Field.h"
#include "overtile/Function.h"
#include "overtile/Grid.h"
#include "overtile/Types.h"
#include <cassert>

namespace overtile {

OpenCLBackEnd::OpenCLBackEnd(Grid *G)
  : BackEnd(G) {
}

OpenCLBackEnd::~OpenCLBackEnd() {
}

void OpenCLBackEnd::codegenDevice(std::ostream &OS) {

  Grid *G = getGrid();
  std::list<Function*> Functions = G->getFunctionList();
  
  OS << "//\n"
     << "// Generated by OverTile\n"
     << "//\n"
     << "// Description:\n"
     << "// OpenCL device code\n"
     << "//\n";

  OS << "__kernel\n"
     << "void ot_kernel(";

  // Generate in/out parameters for each field
  std::list<Field*> Fields = G->getFieldList();

  for (std::list<Field*>::iterator I = Fields.begin(), E = Fields.end(), B = I;
         I != E; ++I) {
    Field *F = *I;
    if (I != B) OS << ", ";
    OS << getTypeName(F->getElementType()) << " *In_" << F->getName();
    OS << ", ";
    OS << getTypeName(F->getElementType()) << " *Out_" << F->getName();
    for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
      OS << ", int " << F->getName() << "_D" << i;
    }
  }

  OS << ") {\n";


  OS << "  // First time step\n";
  InTS0 = true;
  for (std::list<Function*>::iterator I = Functions.begin(),
         E = Functions.end(); I != E; ++I) {
    Function *F = *I;
    Field *Out = F->getOutput();

    OS << "  SHARED_REF(" << Out->getName();
    for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
      OS << ", 0";
    }
    OS << ") = ";
    codegenExpr(F->getExpression(), OS);
    OS << ";\n";
  }

  OS << "  barrier(CLK_LOCAL_MEM_FENCE);\n";

  OS << "  // Remaining time steps\n";
  InTS0 = false;
  OS << "  for (int t = 1; t < " << getTimeTileSize() << "; ++t) {\n";
  for (std::list<Function*>::iterator I = Functions.begin(),
         E = Functions.end(); I != E; ++I) {
    Function *F = *I;
    Field *Out = F->getOutput();

    OS << "    " << getTypeName(Out->getElementType()) << " temp_"
       << Out->getName() << " = ";
    codegenExpr(F->getExpression(), OS);
    OS << "\n";

    OS << "    barrier(CLK_LOCAL_MEM_FENCE);\n";
    OS << "    if (t == " << (getTimeTileSize() - 1) << ") {\n";
    OS << "      OUT_FIELD_REF(" << Out->getName() << ") = temp_"
       << Out->getName() << ";\n";
    OS << "    } else {\n";
    OS << "      SHARED_REF(" << Out->getName();
    for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
      OS << ", 0";
    }
    OS << ") = temp_" << Out->getName() << ";\n";
    OS << "      barrier(CLK_LOCAL_MEM_FENCE);\n";
    OS << "    }\n";
  }
  
  OS << "  }\n";


  // End of kernel
  OS << "} // End of kernel\n";
}

void OpenCLBackEnd::codegenHost(std::ostream &OS) {
  OS << "// TODO\n";
}


std::string OpenCLBackEnd::getTypeName(const ElementType *Ty) {
  if (const FP32Type *FPTy = dynamic_cast<const FP32Type*>(Ty)) {
    return "float";
  } else {
    assert(0 && "Unknown type");
  }
}

void OpenCLBackEnd::codegenExpr(Expression *Expr, std::ostream &OS) {
  if (BinaryOp *Op = dynamic_cast<BinaryOp*>(Expr)) {
    codegenBinaryOp(Op, OS);
  } else if (FieldRef *Ref = dynamic_cast<FieldRef*>(Expr)) {
    codegenFieldRef(Ref, OS);
  } else {
    assert(0 && "Unhandled expression");
  }
}

void OpenCLBackEnd::codegenBinaryOp(BinaryOp *Op, std::ostream &OS) {
  OS << "(";
  codegenExpr(Op->getLHS(), OS);
  switch (Op->getOperator()) {
  default: assert(0 && "Unhandled binary operator"); break;
  case BinaryOp::ADD: OS << "+"; break;
  case BinaryOp::SUB: OS << "-"; break;
  case BinaryOp::MUL: OS << "*"; break;
  case BinaryOp::DIV: OS << "/"; break;
  }
  codegenExpr(Op->getRHS(), OS);
  OS << ")";
}

void OpenCLBackEnd::codegenFieldRef(FieldRef *Ref, std::ostream &OS) {
  Field *F = Ref->getField();
  const std::vector<int> Offsets = Ref->getOffsets();

  if (InTS0) OS << "IN_FIELD_REF(";
  else OS << "SHARED_REF(";
  
  OS << F->getName();

  for (std::vector<int>::const_iterator I = Offsets.begin(), E = Offsets.end();
         I != E; ++I) {
    OS << ", " << *I;
  }
  
  OS << ")";
}

}
