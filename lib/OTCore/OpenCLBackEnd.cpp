
#include "overtile/OpenCLBackEnd.h"
#include "overtile/Expressions.h"
#include "overtile/Field.h"
#include "overtile/Function.h"
#include "overtile/Grid.h"
#include "overtile/Types.h"
#include <cassert>
#include <cmath>

namespace overtile {

OpenCLBackEnd::OpenCLBackEnd(Grid *G)
  : BackEnd(G) {
}

OpenCLBackEnd::~OpenCLBackEnd() {
}

void OpenCLBackEnd::codegenDevice(std::ostream &OS) {

  Grid *G = getGrid();
  std::list<Function*> Functions = G->getFunctionList();
  
  OS << "//\n"
     << "// Generated by OverTile\n"
     << "//\n"
     << "// Description:\n"
     << "// OpenCL device code\n"
     << "//\n";

  OS << "__kernel\n"
     << "void ot_kernel(";

  // Generate in/out parameters for each field
  std::list<Field*> Fields = G->getFieldList();

  for (std::list<Field*>::iterator I = Fields.begin(), E = Fields.end(), B = I;
         I != E; ++I) {
    Field *F = *I;
    if (I != B) OS << ", ";
    OS << "__global " << getTypeName(F->getElementType()) << " *In_"
       << F->getName();
    OS << ", __global ";
    OS << getTypeName(F->getElementType()) << " *Out_" << F->getName();
    OS << ", __local ";
    OS << getTypeName(F->getElementType()) << " *Shared_" << F->getName();
  }
  for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
    OS << ", int Dim_" << i;
  }
  //for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
  //  OS << ", int real_per_block_" << i;
  //}

  for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
    OS << ", int ts_" << i;
  }

  
  OS << ") {\n";

  Region BlockRegion(G->getNumDimensions());
  // Determine region for an entire block
  for (std::map<const Field*, Region>::const_iterator
           I = getRegionMap().begin(),
           E = getRegionMap().end(); I != E; ++I) {
    const Region &R = I->second;
    BlockRegion = Region::makeUnion(BlockRegion, R);
  }
    
  for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
    std::pair<int, unsigned> Bound = BlockRegion.getBound(i);
    int LeftHalo = Bound.first < 0 ? -Bound.first : Bound.first;
    int RightHalo = Bound.second - LeftHalo - 1;
    OS << "  const int Halo_Left_" << i << " = " << LeftHalo << ";\n";
    OS << "  const int Halo_Right_" << i << " = " << RightHalo << ";\n";
  }


  for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
    OS << "  int real_per_block_" << i << " = get_local_size(" << i
       << ") - Halo_Left_" << i << " - Halo_Right_" << i << ";\n";
  }

  OS << "  int array_size = ";
  for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
    if (i != 0) OS << " * ";
    OS << "Dim_" << i;
  }
  OS << ";\n";
  
  for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
    // Find max offsets for all fields.
    unsigned MaxLeft = 0;
    unsigned MaxRight = 0;
    
    for (std::list<Field*>::iterator I = Fields.begin(), E = Fields.end();
           I != E; ++I) {
      Field *InField = *I;
      for (std::list<Function*>::iterator FI = Functions.begin(),
         FE = Functions.end(); FI != FE; ++FI) {
        Function *F = *FI;
        unsigned LeftOffset = 0;
        unsigned RightOffset = 0;
        F->getMaxOffsets(InField, i, LeftOffset, RightOffset);
        MaxLeft = std::max(MaxLeft, LeftOffset);
        MaxRight = std::max(MaxRight, RightOffset);
      }
    }
    
    OS << "  int max_left_offset_" << i << " = " << MaxLeft << ";\n";
    OS << "  int max_right_offset_" << i << " = " << MaxRight << ";\n";
    OS << "  int shared_size_" << i << " = ts_" << i << "*get_local_size(" << i << ") + " << (MaxLeft + MaxRight) << ";\n";
  }

  OS << "int AddrOffset;\n";

  OS << "  // Kernel init\n";
  for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
    OS << "  int local_" << i << " = get_local_id(" << i << ");\n";
    OS << "  int group_" << i << " = get_group_id(" << i << ");\n";
    if (i == 0) {
      OS << "  int tid_" << i << " = group_" << i << " * real_per_block_" << i
         << " + local_" << i << " - Halo_Left_" << i <<";\n";
    } else {
      OS << "  int tid_" << i << " = group_" << i << " * real_per_block_" << i
         << " + local_" << i << "*get_local_size(" << i << ") - Halo_Left_" << i <<";\n";
    }
    OS << "  // Early exit\n";
    OS << "  if (tid_" << i << " >= Dim_" << i << ") return;\n";
  }


  OS << "  // First time step\n";
  for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
    OS << "  for (unsigned elem_" << i << " = 0; elem_" << i << " < ts_" << i << "; ++elem_" << i << ") {\n";
    if (i != 0) {
      OS << "  int thisid_" << i << " = tid_" << i << " + elem_" << i << ";\n";
      OS << "  int thislocal_" << i << " = get_local_id(" << i << ")*ts_" << i << " + elem_" << i << ";\n";
    } else {
      OS << "  int thisid_" << i << " = tid_" << i << " + elem_" << i << "*get_local_size(" << i << ");\n";
      OS << "  int thislocal_" << i << " = elem_" << i << "*ts_" << i << ";\n";
    }
  }
  
  InTS0 = true;
  for (std::list<Function*>::iterator I = Functions.begin(),
         E = Functions.end(); I != E; ++I) {
    Function *F = *I;
    Field *Out = F->getOutput();
    const std::vector<std::pair<unsigned, unsigned> > &Bounds = F->getBounds();

    OS << "  if (";
    for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
      if (i != 0) OS << " && ";
      OS << "(thisid_" << i << " >= " << Bounds[i].first << " && thisid_" << i
         << " < Dim_" << i << " - " << Bounds[i].second << ")";
    }
    OS << ") {\n";
    unsigned Temp = 0;
    OS << "{\n";
    Temp = codegenExpr(F->getExpression(), OS, Temp);

    //OS << "    SHARED_REF(" << Out->getName();
    //for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
    //  OS << ", 0";
    //}
    //OS << ") = temp" << Temp << ";\n";

    OS << "AddrOffset = ";
    unsigned DimTerms = 0;
    unsigned Dim = 0;
    for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
      if (i != 0) OS << " + ";
      OS << "(thislocal_" << i << "+max_left_offset_" << i << ")";
      for (unsigned i = 0; i < DimTerms; ++i) {
        OS << "*shared_size_" << i;
      }
      ++DimTerms;
      ++Dim;
    }
    OS << ";\n";
    OS << "*(Shared_" << Out->getName() << " + AddrOffset) = temp" << Temp << ";\n";
    
    OS << "}\n";
    OS << "  } else {\n";
    OS << "{\n";
    OS << "AddrOffset = ";
    DimTerms = 0;
    Dim = 0;
    for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
      if (i != 0) OS << " + ";
      OS << "(thislocal_" << i << "+max_left_offset_" << i << ")";
      for (unsigned i = 0; i < DimTerms; ++i) {
        OS << "*shared_size_" << i;
      }
      ++DimTerms;
      ++Dim;
    }
    OS << ";\n";
    OS << "*(Shared_" << Out->getName() << " + AddrOffset) = 0;\n";

    OS << "}\n";
    OS << "  }\n";
  }

  OS << "  barrier(CLK_LOCAL_MEM_FENCE);\n";
  for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
    OS << "  }\n";
  }
  
  OS << "  // Remaining time steps\n";
  InTS0 = false;
  OS << "  for (int t = 1; t < " << getTimeTileSize() << "; ++t) {\n";

  for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
    OS << "  for (unsigned elem_" << i << " = 0; elem_" << i << " < ts_" << i << "; ++elem_" << i << ") {\n";
    if (i != 0) {
      OS << "  int thisid_" << i << " = tid_" << i << " + elem_" << i << ";\n";
      OS << "  int thislocal_" << i << " = get_local_id(" << i << ")*ts_" << i << " + elem_" << i << ";\n";
    } else {
      OS << "  int thisid_" << i << " = tid_" << i << " + elem_" << i << "*get_local_size(" << i << ");\n";
      OS << "  int thislocal_" << i << " = elem_" << i << "*ts_" << i << ";\n";
    }
  }


  for (std::list<Function*>::iterator I = Functions.begin(),
         E = Functions.end(); I != E; ++I) {
    Function *F = *I;
    Field *Out = F->getOutput();

    unsigned Temp = 0;
    OS << "{\n";
    Temp = codegenExpr(F->getExpression(), OS, Temp);
    OS << "    " << getTypeName(Out->getElementType()) << " temp_"
       << Out->getName() << " = temp" << Temp;
    OS << ";\n";
    OS << "    barrier(CLK_LOCAL_MEM_FENCE);\n";
    OS << "    if (t == " << (getTimeTileSize() - 1) << ") {\n";

    // Output guard
    OS << "      if (";
    for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
      if (i != 0) OS << " && ";
      OS << "(thislocal_" << i << " >= Halo_Left_" << i
         << " && thislocal_" << i << " < get_local_size(" << i
         << ")*ts_" << i << " - Halo_Right_" << i << ")";
    }
    OS << ") {\n";

    //OS << "        OUT_FIELD_REF(" << Out->getName() << ") = temp_"
    //   << Out->getName() << ";\n";
    OS << "AddrOffset = ";
    unsigned DimTerms = 0;
    unsigned Dim = 0;
    for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
      if (i != 0) OS << " + ";
      OS << "thisid_" << i;
      for (unsigned i = 0; i < DimTerms; ++i) {
        OS << "*Dim_" << i;
      }
      ++DimTerms;
      ++Dim;
    }
    OS << ";\n";
    OS << "*(Out_" << Out->getName() << " + AddrOffset) = temp_" << Out->getName() << ";\n";

    
    OS << "      }\n";
    OS << "    } else {\n";
    //OS << "      SHARED_REF(" << Out->getName();
    //for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
    //  OS << ", 0";
    //}
    //OS << ") = temp_" << Out->getName() << ";\n";

    OS << "AddrOffset = ";
    DimTerms = 0;
    Dim = 0;
    for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
      if (i != 0) OS << " + ";
      OS << "(thislocal_" << i << "+max_left_offset_" << i << ")";
      for (unsigned i = 0; i < DimTerms; ++i) {
        OS << "*shared_size_" << i;
      }
      ++DimTerms;
      ++Dim;
    }
    OS << ";\n";
    OS << "      barrier(CLK_LOCAL_MEM_FENCE);\n";
    OS << "*(Shared_" << Out->getName() << " + AddrOffset) = temp_" << Out->getName() << ";\n";

    
    OS << "      barrier(CLK_LOCAL_MEM_FENCE);\n";
    OS << "    }\n";
  }
  OS << "}\n";

  for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
    OS << "  }\n";
  }

  OS << "  }\n";


  // End of kernel
  OS << "} // End of kernel\n";
}

void OpenCLBackEnd::codegenHost(std::ostream &OS) {
  Grid *G = getGrid();
  std::list<Function*> Functions = G->getFunctionList();

  OS << "//\n"
     << "// Generated by OverTile\n"
     << "//\n"
     << "// Description:\n"
     << "// OpenCL host code\n"
     << "//\n";

  OS << "#include \"overtile/cl/CLCommon.h\"\n";
  OS << "#include \"overtile/cl/CLContext.h\"\n";
  OS << "#include <fstream>\n";
  OS << "#include <cassert>\n";
  OS << "using namespace overtile;\n";
  OS << "void ot_program(const char *FileName, int timesteps";
  // Generate in/out parameters for each field
  std::list<Field*> Fields = G->getFieldList();

  for (std::list<Field*>::iterator I = Fields.begin(), E = Fields.end();
         I != E; ++I) {
    Field *F = *I;
    OS << ", ";
    OS << getTypeName(F->getElementType()) << " *Host_" << F->getName();
  }
  for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
    OS << ", int Dim_" << i;
  }

  for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
    OS << ", int BlockDim_" << i;
  }

  for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
    OS << ", int ts_" << i;
  }

  OS << ") {\n";


  // OpenCL Init
  OS << "  cl_int Result;\n";
  OS << "  CLContext Context;\n";
  OS << "  cl::CommandQueue Queue(Context.context(), Context.device(), 0, &Result);\n";
  OS << "  CLContext::throwOnError(\"cl::CommandQueue\", Result);\n";
  OS << "  std::ifstream KernelStream(FileName);\n";
  OS << "  std::string Source = std::string(std::istreambuf_iterator<char>(KernelStream), (std::istreambuf_iterator<char>()));\n";
  OS << "  cl::Program::Sources ProgSource(1, std::make_pair(Source.c_str(), Source.size()));\n";
  OS << "  cl::Program Program(Context.context(), ProgSource, &Result);\n";
  OS << "  CLContext::throwOnError(\"cl::Program failed\", Result);\n";
  OS << "  std::vector<cl::Device> Devices;\n";
  OS << "  Devices.push_back(Context.device());\n";
  OS << "  Result = Program.build(Devices, \"-cl-nv-verbose\");\n";
  OS << "  if (Result != CL_SUCCESS) {\n";
  OS << "    std::cout << \"Program compilation failed!\\n\";\n";
  OS << "    std::cout << Program.getBuildInfo<CL_PROGRAM_BUILD_LOG>(Context.device());\n";
  OS << "    throw std::runtime_error(\"Error!\");\n";
  OS << "  }\n";
  OS << "  cl::Kernel Kernel(Program, \"ot_kernel\", &Result);\n";
  OS << "  CLContext::throwOnError(\"Failed to extract kernel\", Result);\n";

  OS << "  int ArraySize = Dim_0";
  for (unsigned i = 1, e = G->getNumDimensions(); i < e; ++i) {
      OS << "*Dim_" << i;
  }
  OS << ";\n";
  
  for (std::list<Field*>::iterator I = Fields.begin(), E = Fields.end();
         I != E; ++I) {
    Field *F = *I;
    OS << "  cl::Buffer device" << F->getName() << "_In(Context.context(), CL_MEM_READ_WRITE, sizeof(" << getTypeName(F->getElementType()) << ")*ArraySize";
    OS << ", NULL, &Result);\n";
    OS << "  CLContext::throwOnError(\"Failed to allocate data\", Result);\n";
    OS << "  cl::Buffer device" << F->getName() << "_Out(Context.context(), CL_MEM_READ_WRITE, sizeof(" << getTypeName(F->getElementType()) << ")*ArraySize";
    OS << ", NULL, &Result);\n";
    OS << "  CLContext::throwOnError(\"Failed to allocate data\", Result);\n";
    OS << "  cl::Buffer *device" << F->getName() << "_InPtr = &device" << F->getName() << "_In;\n";
    OS << "  cl::Buffer *device" << F->getName() << "_OutPtr = &device" << F->getName() << "_Out;\n";
    OS << "  Result = Queue.enqueueWriteBuffer(*device" << F->getName()
       << "_InPtr, CL_TRUE, 0, sizeof("
       << getTypeName(F->getElementType()) << ")*ArraySize, Host_" << F->getName() << ", NULL, NULL);\n";
    OS << "  CLContext::throwOnError(\"Copy\", Result);\n";
  }  

  Region BlockRegion(G->getNumDimensions());
  // Determine region for an entire block
  for (std::map<const Field*, Region>::const_iterator
           I = getRegionMap().begin(),
           E = getRegionMap().end(); I != E; ++I) {
    const Region &R = I->second;
    BlockRegion = Region::makeUnion(BlockRegion, R);
  }

  
  for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
    std::pair<int, unsigned> Bound = BlockRegion.getBound(i);
    int LeftHalo = Bound.first < 0 ? -Bound.first : Bound.first;
    int RightHalo = Bound.second - LeftHalo - 1;
    OS << "  const int Halo_Left_" << i << " = " << LeftHalo << ";\n";
    OS << "  const int Halo_Right_" << i << " = " << RightHalo << ";\n";
  }


  for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
    OS << "  int real_per_block_" << i << " = ts_" << i << "*BlockDim_" << i
       << " - Halo_Left_" << i << " - Halo_Right_" << i << ";\n";
    OS << "  assert(real_per_block_" << i << " > 0);\n";
  }


  for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
    // Find max offsets for all fields.
    unsigned MaxLeft = 0;
    unsigned MaxRight = 0;
    
    for (std::list<Field*>::iterator I = Fields.begin(), E = Fields.end();
           I != E; ++I) {
      Field *InField = *I;
      for (std::list<Function*>::iterator FI = Functions.begin(),
         FE = Functions.end(); FI != FE; ++FI) {
        Function *F = *FI;
        unsigned LeftOffset = 0;
        unsigned RightOffset = 0;
        F->getMaxOffsets(InField, i, LeftOffset, RightOffset);
        MaxLeft = std::max(MaxLeft, LeftOffset);
        MaxRight = std::max(MaxRight, RightOffset);
      }
    }

    
    OS << "  int shared_size_" << i << " = ts_" << i << "*BlockDim_" << i << " + " << (MaxLeft + MaxRight) << ";\n";
  }



  OS << "  int shared_size = shared_size_0";
  for (unsigned i = 1, e = G->getNumDimensions(); i < e; ++i) {
    OS << "*shared_size_" << i;
  }
  OS << ";\n";

  OS << "  cl::NDRange local_size(BlockDim_0";
  for (unsigned i = 1, e = G->getNumDimensions(); i < e; ++i) {
    OS << ", BlockDim_" << i;
  }
  OS << ");\n";

  for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
    OS << "  int num_blocks_" << i << " = Dim_" << i << " / real_per_block_" << i
       << ";\n";
    OS << "  int extra_" << i << " = Dim_" << i << " % real_per_block_" << i << ";\n";
    OS << "  num_blocks_" << i << " = num_blocks_" << i << " + (extra_"
       << i << " > 0 ? 1 : 0);\n";
  }

  OS << "  cl::NDRange global_size(BlockDim_0 * num_blocks_0";
  for (unsigned i = 1, e = G->getNumDimensions(); i < e; ++i) {
    OS << ", BlockDim_" << i << " * num_blocks_" << i;
  }
  OS << ");\n";

  
  OS << "  std::cout << \"Global: \" << ((const size_t*)global_size)[0] << \", \" << ((const size_t*)global_size)[1] << \"\\n\";\n";
  OS << "  std::cout << \"Local: \" << ((const size_t*)local_size)[0] << \", \" << (( const size_t*)local_size)[1] << \"\\n\";\n";
  
  OS << "  cl::Event WaitEvent;\n";

  OS << "  double TStart = rtclock();\n";
  
  OS << "  for (int t = 0; t < timesteps; t += " << getTimeTileSize()
     << ") {\n";
  
  unsigned ArgNo = 0;
  for (std::list<Field*>::iterator I = Fields.begin(), E = Fields.end();
           I != E; ++I) {
    Field *F = *I;
    OS << "    Result = Kernel.setArg(" << ArgNo++ << ", *device"
       << F->getName() << "_InPtr);\n";
    OS << "    CLContext::throwOnError(\"Arg\", Result);\n";
    OS << "    Result = Kernel.setArg(" << ArgNo++ << ", *device"
       << F->getName() << "_OutPtr);\n";
    OS << "    CLContext::throwOnError(\"Arg\", Result);\n";
    OS << "    Result = Kernel.setArg(" << ArgNo++ << ", shared_size*sizeof(" << getTypeName(F->getElementType()) << "), NULL);\n";
    OS << "    CLContext::throwOnError(\"Arg\", Result);\n";
  }

  for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
    OS << "    Result = Kernel.setArg(" << ArgNo++ << ", Dim_" << i << ");\n";
    OS << "    CLContext::throwOnError(\"Arg\", Result);\n";
  }

  for (unsigned i = 0, e = G->getNumDimensions(); i < e; ++i) {
    OS << "    Result = Kernel.setArg(" << ArgNo++ << ", ts_" << i << ");\n";
    OS << "    CLContext::throwOnError(\"Arg\", Result);\n";
  }


  OS << "    Result = Queue.enqueueNDRangeKernel(Kernel, cl::NullRange, global_size, local_size, 0, &WaitEvent);\n";
  OS << "    CLContext::throwOnError(\"Launch\", Result);\n";

  for (std::list<Field*>::iterator I = Fields.begin(), E = Fields.end();
           I != E; ++I) {
    Field *F = *I;
    OS << "    std::swap(device" << F->getName() << "_InPtr, device"
       << F->getName() << "_OutPtr);\n";
  }
  
  OS << "  }\n";

  OS << "  WaitEvent.wait();\n";

  OS << "  double TEnd = rtclock();\n";
    
  for (std::list<Field*>::iterator I = Fields.begin(), E = Fields.end();
           I != E; ++I) {
    Field *F = *I;
    OS << "  Result = Queue.enqueueReadBuffer(*device" << F->getName()
       << "_InPtr, CL_TRUE, 0, sizeof("
       << getTypeName(F->getElementType()) << ")*ArraySize, Host_" << F->getName() << ", NULL, NULL);\n";
    OS << "  CLContext::throwOnError(\"Copy\", Result);\n";
  }

  OS << "  double Flops = 0.0;\n";
  OS << "  double Points;\n";
  for (std::list<Function*>::iterator FI = Functions.begin(),
         FE = Functions.end(); FI != FE; ++FI) {
    Function *F = *FI;
    double Flops = F->countFlops();
    const std::vector<std::pair<unsigned, unsigned> > &Bounds = F->getBounds();

    OS << "  Points = (Dim_0-" << (Bounds[0].first+Bounds[0].second) << ")";
    for (unsigned i = 1, e = Bounds.size(); i < e; ++i) {
      OS << " * (Dim_" << i << "-" << (Bounds[i].first+Bounds[i].second) << ")";
    }
    OS << ";\n";
    OS << "  Flops = Flops + Points * " << Flops << ";\n";
  }
  OS << "  Flops = Flops * timesteps;\n";
  OS << "  double Elapsed = TEnd - TStart;\n";
  OS << "  double GFlops = Flops / Elapsed / 1e9;\n";
  OS << "  std::cerr << \"GFlops: \" << GFlops << \"\\n\";\n";
  
  OS << "}\n";
}


std::string OpenCLBackEnd::getTypeName(const ElementType *Ty) {
  if (const FP32Type *FPTy = dynamic_cast<const FP32Type*>(Ty)) {
    return "float";
  } else {
    assert(0 && "Unknown type");
  }
}

unsigned OpenCLBackEnd::codegenExpr(Expression *Expr, std::ostream &OS,
                                    unsigned &TempIdx) {
  if (BinaryOp *Op = dynamic_cast<BinaryOp*>(Expr)) {
    return codegenBinaryOp(Op, OS, TempIdx);
  } else if (FieldRef *Ref = dynamic_cast<FieldRef*>(Expr)) {
    return codegenFieldRef(Ref, OS, TempIdx);
  } else if (ConstantExpr *C = dynamic_cast<ConstantExpr*>(Expr)) {
    return codegenConstant(C, OS, TempIdx);
  } else {
    assert(0 && "Unhandled expression");
  }
}

unsigned OpenCLBackEnd::codegenBinaryOp(BinaryOp *Op, std::ostream &OS,
                                        unsigned &TempIdx) {
  unsigned L = codegenExpr(Op->getLHS(), OS, TempIdx);
  unsigned R = codegenExpr(Op->getRHS(), OS, TempIdx);
  // @FIXME: Hard-coded float!
  OS << "float temp" << TempIdx << " = temp" << L;
  switch (Op->getOperator()) {
  default: assert(0 && "Unhandled binary operator"); break;
  case BinaryOp::ADD: OS << "+"; break;
  case BinaryOp::SUB: OS << "-"; break;
  case BinaryOp::MUL: OS << "*"; break;
  case BinaryOp::DIV: OS << "/"; break;
  }
  OS << "temp" << R << ";\n";
  return TempIdx++;
}

unsigned OpenCLBackEnd::codegenFieldRef(FieldRef *Ref, std::ostream &OS,
                                        unsigned &TempIdx) {
  Field *F = Ref->getField();
  const std::vector<int> Offsets = Ref->getOffsets();

  std::string Prefix;
  
  if (InTS0) Prefix = "In_";
  else Prefix = "Shared_";
  
  std::string Name = F->getName();

  OS << "AddrOffset = ";

  unsigned DimTerms = 0;

  unsigned Dim = 0;
  for (std::vector<int>::const_iterator I = Offsets.begin(),
         E = Offsets.end(), B = I; I != E; ++I) {
    int Offset = *I;
    if (B != I) OS << " + ";
    if (InTS0)
      OS << "(thisid_" << Dim << "+" << *I << ")";
    else
      OS << "((thislocal_" << Dim << "+" << *I << ")+max_left_offset_" << Dim << ")";
    for (unsigned i = 0; i < DimTerms; ++i) {
      if (InTS0)
        OS << "*Dim_" << i;
      else
        OS << "*thislocal_" << i << "";
    }
    ++DimTerms;
    ++Dim;
  }
  OS << ";\n";

  if (InTS0) {
    OS << "AddrOffset = max(AddrOffset, 0);\n";
    OS << "AddrOffset = min(AddrOffset, array_size-1);\n";
  }
  
  // @FIXME: Hard-coded float!
  OS << "float temp" << TempIdx << " = *(" << Prefix << Name
     << " + AddrOffset);\n";
  
  return TempIdx++;
}

unsigned OpenCLBackEnd::
codegenConstant(ConstantExpr *Expr, std::ostream &OS, unsigned &TempIdx) {
  if (dynamic_cast<FP32Constant*>(Expr)) {
    OS << "  float temp" << TempIdx << " = " << Expr->getStringValue() << "f;\n";
  } else {
    assert(0 && "Unknown type");
  }

  return TempIdx++;
}

}
