
#include <sys/time.h>
#include <iostream>

#ifndef PROBLEM_SIZE
#define PROBLEM_SIZE 4000
#endif

#ifndef TIME_STEPS
#define TIME_STEPS 50
#endif


inline double rtclock() {
  struct timeval Tp;
  gettimeofday(&Tp, NULL);
  return (Tp.tv_sec + Tp.tv_usec * 1.0e-6);
}


template <typename T>
bool CompareResult(T *Result, T *Reference, size_t Size) {
  
  T ErrorNorm = 0.0;
  T RefNorm   = 0.0;

  for (unsigned i = 0; i < Size; ++i) {
    float Diff  = Result[i] - Reference[i];
    ErrorNorm  += Diff*Diff;
    RefNorm    += Reference[i]*Reference[i];
  }

  ErrorNorm = std::sqrt(ErrorNorm);
  RefNorm   = std::sqrt(RefNorm);

  std::cout << "Error Norm:  " << ErrorNorm << "\n";
  std::cout << "Ref Norm:    " << RefNorm << "\n";
 
  if(std::abs(RefNorm) < 1e-7) {
    std::cout << "FAIL!\n";
    return false;
  }
  else if((ErrorNorm / RefNorm) > 1e-2) {
    std::cout << "FAIL!\n";
    return false;
  }
  else {
    std::cout << "OK\n";
    return true;
  }
}


void reference(float *u, const float *v, const float *f) {

  int   p, n;
  int   Iter;
  float r;
  
  const int M = PROBLEM_SIZE;
  const int N = PROBLEM_SIZE;

  const float DT      = 5.0f;
  const float EPSILON = 1.0E-20f;

  float sigma  = 1.00001f;
  float sigma2 = sigma*sigma;
  float lambda = 1.00001f;
  float gamma  = lambda/sigma2;


  float *Temp = new float[M*N];

  memcpy(Temp, u, sizeof(float)*M*N);
  
#define SQR(x) ((x)*(x))
  


  delete [] Temp;
}


int main() {

  const int Dim_0 = PROBLEM_SIZE;
  const int Dim_1 = PROBLEM_SIZE;
  
  float *U = new float[Dim_0*Dim_1];
  float *V = new float[Dim_0*Dim_1];
  float *F = new float[Dim_0*Dim_1];


  srand(time(NULL));
  
  for (int i = 0; i < Dim_0*Dim_1; ++i) {
    V[i] = (float)rand() / (float)(RAND_MAX+1.0f);
    U[i] = (float)rand() / (float)(RAND_MAX+1.0f);
    F[i] = (float)rand() / (float)(RAND_MAX+1.0f);
  }
  
  float *RefU = new float[Dim_0*Dim_1];
  float *RefV = new float[Dim_0*Dim_1];
  float *RefF = new float[Dim_0*Dim_1];

  memcpy(RefU, U, sizeof(float)*Dim_0*Dim_1);
  memcpy(RefV, V, sizeof(float)*Dim_0*Dim_1);
  memcpy(RefF, F, sizeof(float)*Dim_0*Dim_1);


  double RefStart = rtclock();
  
  //reference(RefU, F, RefG);

  double RefStop = rtclock();

  
  cudaThreadSynchronize();

  double Start = rtclock();
  
////// BEGIN OVERTILE CODEGEN
void ot_program_tv2d(int timesteps, float *Host_U, float *Host_V, float *Host_F, int Dim_0, int Dim_1);
ot_program_tv2d(TIME_STEPS, U, V, F, Dim_0, Dim_1);
////// END OVERTILE CODEGEN


  double Stop = rtclock();

  std::cout << "CPU Elapsed: " << (Stop-Start) << "\n";
  std::cout << "Ref Elapsed: " << (RefStop - RefStart) << "\n";


  std::cout << "Check U...\n";
  CompareResult(U, RefU, Dim_0*Dim_1);



#ifdef PRINT
  //for (int i = 0; i < PROBLEM_SIZE*PROBLEM_SIZE*PROBLEM_SIZE; ++i) {
  //  std::cout << "U: " << U[i] << "  -  Ref U: " << RefU[i] << "\n";
  //}

  for (int i = 1; i < PROBLEM_SIZE-1; ++i) {
    for (int j = 1; j < PROBLEM_SIZE-1; ++j) {
      for (int k = 1; k < PROBLEM_SIZE-1; ++k) {
        std::cout << "U[i][j][k]: " << U[i*PROBLEM_SIZE*PROBLEM_SIZE+j*PROBLEM_SIZE+k] << "  -  RefU[i][j][k]: " << RefU[i*PROBLEM_SIZE*PROBLEM_SIZE+j*PROBLEM_SIZE+k] << "\n";          
      }
    }
  }


  for (int i = 0; i < PROBLEM_SIZE; ++i) {
    for (int j = 0; j < PROBLEM_SIZE; ++j) {
      for (int k = 0; k < PROBLEM_SIZE; ++k) {
        std::cout << "G[i][j][k]: " << G[i*PROBLEM_SIZE*PROBLEM_SIZE+j*PROBLEM_SIZE+k] << "  -  RefG[i][j][k]: " << RefG[i*PROBLEM_SIZE*PROBLEM_SIZE+j*PROBLEM_SIZE+k] << "\n";          
      }
    }
  }

#endif


  delete [] U;
  delete [] V;
  delete [] RefU;
  delete [] RefV;

  return 0;
}


////// BEGIN OVERTILE GENERATED CODE
//
// Generated by OverTile
//
// Description:
// CUDA device code
//
__global__
static void ot_kernel_tv2d(float *In_U, float *Out_U, float *In_V, float *Out_V, float *In_F, float *Out_F, int Dim_0, int Dim_1) {
  __shared__ float Shared_U[32+1+1][64+1+1];
  __shared__ float Shared_V[32+1+1][64+1+1];
  __shared__ float Shared_F[32+1+1][64+1+1];
  const int Halo_Left_0 = 0;
  const int Halo_Right_0 = 0;
  const int Halo_Left_1 = 0;
  const int Halo_Right_1 = 0;
  int real_per_block_0 = 1*blockDim.x - Halo_Left_0 - Halo_Right_0;
  int real_per_block_1 = 4*blockDim.y - Halo_Left_1 - Halo_Right_1;
  int array_size = Dim_0 * Dim_1;
  const int ts_0 = 1;
  const int ts_1 = 4;
  float Buffer_U[4][1];
  float Buffer_V[4][1];
  float Buffer_F[4][1];
  int max_left_offset_0 = 1;
  int max_right_offset_0 = 1;
  int max_left_offset_1 = 1;
  int max_right_offset_1 = 1;
int AddrOffset;
  // Kernel init
  int local_0 = threadIdx.x;
  int group_0 = blockIdx.x;
  int tid_0 = group_0 * real_per_block_0 + local_0 - Halo_Left_0;
  int local_1 = threadIdx.y;
  int group_1 = blockIdx.y;
  int tid_1 = group_1 * real_per_block_1 + local_1*4 - Halo_Left_1;
  // First time step
  for (unsigned elem_0 = 0; elem_0 < ts_0; ++elem_0) {
  int thisid_0 = tid_0 + elem_0*blockDim.x;
  int thislocal_0 = local_0 + elem_0*blockDim.x;
  for (unsigned elem_1 = 0; elem_1 < ts_1; ++elem_1) {
  int thisid_1 = tid_1 + elem_1;
  int thislocal_1 = threadIdx.y*ts_1 + elem_1;
  if ((thisid_0 >= 0 && thisid_0 < Dim_0 - 0) && (thisid_1 >= 0 && thisid_1 < Dim_1 - 0)) {
{
AddrOffset = (thisid_0+0) + (thisid_1+0)*Dim_0;
float F_0_0 = *(In_F + AddrOffset);
  float Res = F_0_0;
  Buffer_F[elem_1][elem_0] = Res;
  }
} else if ((thisid_0 >= 0 && thisid_0 < Dim_0) && (thisid_1 >= 0 && thisid_1 < Dim_1)) {
AddrOffset = (thisid_0+0) + (thisid_1+0)*Dim_0;
float temp = *(In_F + AddrOffset);
  Buffer_F[elem_1][elem_0] = temp;
  } else {
  Buffer_F[elem_1][elem_0] = 0;
  }
  }
  }
  __syncthreads();
  for (unsigned elem_0 = 0; elem_0 < ts_0; ++elem_0) {
  int thisid_0 = tid_0 + elem_0*blockDim.x;
  int thislocal_0 = local_0 + elem_0*blockDim.x;
  for (unsigned elem_1 = 0; elem_1 < ts_1; ++elem_1) {
  int thisid_1 = tid_1 + elem_1;
  int thislocal_1 = threadIdx.y*ts_1 + elem_1;
Shared_F[thislocal_1+1][thislocal_0+1] = Buffer_F[elem_1][elem_0];
  }
  }
  __syncthreads();
  for (unsigned elem_0 = 0; elem_0 < ts_0; ++elem_0) {
  int thisid_0 = tid_0 + elem_0*blockDim.x;
  int thislocal_0 = local_0 + elem_0*blockDim.x;
  for (unsigned elem_1 = 0; elem_1 < ts_1; ++elem_1) {
  int thisid_1 = tid_1 + elem_1;
  int thislocal_1 = threadIdx.y*ts_1 + elem_1;
  if ((thisid_0 >= 0 && thisid_0 < Dim_0 - 0) && (thisid_1 >= 0 && thisid_1 < Dim_1 - 0)) {
{
AddrOffset = (thisid_0+0) + (thisid_1+0)*Dim_0;
float V_0_0 = *(In_V + AddrOffset);
  float Res = V_0_0;
  Buffer_V[elem_1][elem_0] = Res;
  }
} else if ((thisid_0 >= 0 && thisid_0 < Dim_0) && (thisid_1 >= 0 && thisid_1 < Dim_1)) {
AddrOffset = (thisid_0+0) + (thisid_1+0)*Dim_0;
float temp = *(In_V + AddrOffset);
  Buffer_V[elem_1][elem_0] = temp;
  } else {
  Buffer_V[elem_1][elem_0] = 0;
  }
  }
  }
  __syncthreads();
  for (unsigned elem_0 = 0; elem_0 < ts_0; ++elem_0) {
  int thisid_0 = tid_0 + elem_0*blockDim.x;
  int thislocal_0 = local_0 + elem_0*blockDim.x;
  for (unsigned elem_1 = 0; elem_1 < ts_1; ++elem_1) {
  int thisid_1 = tid_1 + elem_1;
  int thislocal_1 = threadIdx.y*ts_1 + elem_1;
Shared_V[thislocal_1+1][thislocal_0+1] = Buffer_V[elem_1][elem_0];
  }
  }
  __syncthreads();
  for (unsigned elem_0 = 0; elem_0 < ts_0; ++elem_0) {
  int thisid_0 = tid_0 + elem_0*blockDim.x;
  int thislocal_0 = local_0 + elem_0*blockDim.x;
  for (unsigned elem_1 = 0; elem_1 < ts_1; ++elem_1) {
  int thisid_1 = tid_1 + elem_1;
  int thislocal_1 = threadIdx.y*ts_1 + elem_1;
  if ((thisid_0 >= 1 && thisid_0 < Dim_0 - 1) && (thisid_1 >= 1 && thisid_1 < Dim_1 - 1)) {
{
AddrOffset = (thisid_0+0) + (thisid_1+0)*Dim_0;
float U_0_0 = *(In_U + AddrOffset);
AddrOffset = (thisid_0+0) + (thisid_1+1)*Dim_0;
float U_0_p1 = *(In_U + AddrOffset);
AddrOffset = (thisid_0+1) + (thisid_1+0)*Dim_0;
float U_p1_0 = *(In_U + AddrOffset);
float V_0_0 = Shared_V[thislocal_1+1+0][thislocal_0+1+0];
AddrOffset = (thisid_0+0) + (thisid_1+-1)*Dim_0;
float U_0_m1 = *(In_U + AddrOffset);
AddrOffset = (thisid_0+1) + (thisid_1+-1)*Dim_0;
float U_p1_m1 = *(In_U + AddrOffset);
AddrOffset = (thisid_0+-1) + (thisid_1+1)*Dim_0;
float U_m1_p1 = *(In_U + AddrOffset);
AddrOffset = (thisid_0+-1) + (thisid_1+0)*Dim_0;
float U_m1_0 = *(In_U + AddrOffset);
float F_0_0 = Shared_F[thislocal_1+1+0][thislocal_0+1+0];
  float Res = ((1.0f/((((1.1f+((U_0_0*rsqrtf(((9.9999999E-9f+((U_0_p1-U_0_0)*(U_0_p1-U_0_0)))+((U_p1_0-U_0_0)*(U_p1_0-U_0_0)))))/V_0_0))+((U_0_0*rsqrtf(((9.9999999E-9f+((U_0_0-U_0_m1)*(U_0_0-U_0_m1)))+((U_p1_m1-U_0_m1)*(U_p1_m1-U_0_m1)))))/V_0_0))+((U_0_0*rsqrtf(((9.9999999E-9f+((U_0_p1-U_0_0)*(U_0_p1-U_0_0)))+((U_p1_0-U_0_0)*(U_p1_0-U_0_0)))))/V_0_0))+((U_0_0*rsqrtf(((9.9999999E-9f+((U_m1_p1-U_m1_0)*(U_m1_p1-U_m1_0)))+((U_0_0-U_m1_0)*(U_0_0-U_m1_0)))))/V_0_0)))*(((((1.1f*F_0_0)+(((U_0_0*rsqrtf(((9.9999999E-9f+((U_0_p1-U_0_0)*(U_0_p1-U_0_0)))+((U_p1_0-U_0_0)*(U_p1_0-U_0_0)))))/V_0_0)*U_0_p1))+(((U_0_0*rsqrtf(((9.9999999E-9f+((U_0_0-U_0_m1)*(U_0_0-U_0_m1)))+((U_p1_m1-U_0_m1)*(U_p1_m1-U_0_m1)))))/V_0_0)*U_0_m1))+(((U_0_0*rsqrtf(((9.9999999E-9f+((U_0_p1-U_0_0)*(U_0_p1-U_0_0)))+((U_p1_0-U_0_0)*(U_p1_0-U_0_0)))))/V_0_0)*U_p1_0))+(((U_0_0*rsqrtf(((9.9999999E-9f+((U_m1_p1-U_m1_0)*(U_m1_p1-U_m1_0)))+((U_0_0-U_m1_0)*(U_0_0-U_m1_0)))))/V_0_0)*U_m1_0)));
  Buffer_U[elem_1][elem_0] = Res;
  }
} else if ((thisid_0 >= 0 && thisid_0 < Dim_0) && (thisid_1 >= 0 && thisid_1 < Dim_1)) {
AddrOffset = (thisid_0+0) + (thisid_1+0)*Dim_0;
float temp = *(In_U + AddrOffset);
  Buffer_U[elem_1][elem_0] = temp;
  } else {
  Buffer_U[elem_1][elem_0] = 0;
  }
  }
  }
  __syncthreads();
  for (unsigned elem_0 = 0; elem_0 < ts_0; ++elem_0) {
  int thisid_0 = tid_0 + elem_0*blockDim.x;
  int thislocal_0 = local_0 + elem_0*blockDim.x;
  for (unsigned elem_1 = 0; elem_1 < ts_1; ++elem_1) {
  int thisid_1 = tid_1 + elem_1;
  int thislocal_1 = threadIdx.y*ts_1 + elem_1;
Shared_U[thislocal_1+1][thislocal_0+1] = Buffer_U[elem_1][elem_0];
  }
  }
  __syncthreads();
  // Remaining time steps
  for (int t = 1; t < 1; ++t) {
  for (unsigned elem_0 = 0; elem_0 < ts_0; ++elem_0) {
  int thisid_0 = tid_0 + elem_0*blockDim.x;
  int thislocal_0 = local_0 + elem_0*blockDim.x;
  for (unsigned elem_1 = 0; elem_1 < ts_1; ++elem_1) {
  int thisid_1 = tid_1 + elem_1;
  int thislocal_1 = threadIdx.y*ts_1 + elem_1;
{
float F_0_0 = Shared_F[thislocal_1+1+0][thislocal_0+1+0];
  float Res = F_0_0;
    Buffer_F[elem_1][elem_0] = Res;
  }
  }
}
 __syncthreads();
  for (unsigned elem_0 = 0; elem_0 < ts_0; ++elem_0) {
  int thisid_0 = tid_0 + elem_0*blockDim.x;
  int thislocal_0 = local_0 + elem_0*blockDim.x;
  for (unsigned elem_1 = 0; elem_1 < ts_1; ++elem_1) {
  int thisid_1 = tid_1 + elem_1;
  int thislocal_1 = threadIdx.y*ts_1 + elem_1;
    if ((thisid_0 >= 0 && thisid_0 < Dim_0 - 0) && (thisid_1 >= 0 && thisid_1 < Dim_1 - 0)) {
Shared_F[thislocal_1+1][thislocal_0+1] = Buffer_F[elem_1][elem_0];
    }
  }
  }
 __syncthreads();
  for (unsigned elem_0 = 0; elem_0 < ts_0; ++elem_0) {
  int thisid_0 = tid_0 + elem_0*blockDim.x;
  int thislocal_0 = local_0 + elem_0*blockDim.x;
  for (unsigned elem_1 = 0; elem_1 < ts_1; ++elem_1) {
  int thisid_1 = tid_1 + elem_1;
  int thislocal_1 = threadIdx.y*ts_1 + elem_1;
{
float V_0_0 = Shared_V[thislocal_1+1+0][thislocal_0+1+0];
  float Res = V_0_0;
    Buffer_V[elem_1][elem_0] = Res;
  }
  }
}
 __syncthreads();
  for (unsigned elem_0 = 0; elem_0 < ts_0; ++elem_0) {
  int thisid_0 = tid_0 + elem_0*blockDim.x;
  int thislocal_0 = local_0 + elem_0*blockDim.x;
  for (unsigned elem_1 = 0; elem_1 < ts_1; ++elem_1) {
  int thisid_1 = tid_1 + elem_1;
  int thislocal_1 = threadIdx.y*ts_1 + elem_1;
    if ((thisid_0 >= 0 && thisid_0 < Dim_0 - 0) && (thisid_1 >= 0 && thisid_1 < Dim_1 - 0)) {
Shared_V[thislocal_1+1][thislocal_0+1] = Buffer_V[elem_1][elem_0];
    }
  }
  }
 __syncthreads();
  for (unsigned elem_0 = 0; elem_0 < ts_0; ++elem_0) {
  int thisid_0 = tid_0 + elem_0*blockDim.x;
  int thislocal_0 = local_0 + elem_0*blockDim.x;
  for (unsigned elem_1 = 0; elem_1 < ts_1; ++elem_1) {
  int thisid_1 = tid_1 + elem_1;
  int thislocal_1 = threadIdx.y*ts_1 + elem_1;
{
float U_0_0 = Shared_U[thislocal_1+1+0][thislocal_0+1+0];
float U_0_p1 = Shared_U[thislocal_1+1+1][thislocal_0+1+0];
float U_p1_0 = Shared_U[thislocal_1+1+0][thislocal_0+1+1];
float V_0_0 = Shared_V[thislocal_1+1+0][thislocal_0+1+0];
float U_0_m1 = Shared_U[thislocal_1+1+-1][thislocal_0+1+0];
float U_p1_m1 = Shared_U[thislocal_1+1+-1][thislocal_0+1+1];
float U_m1_p1 = Shared_U[thislocal_1+1+1][thislocal_0+1+-1];
float U_m1_0 = Shared_U[thislocal_1+1+0][thislocal_0+1+-1];
float F_0_0 = Shared_F[thislocal_1+1+0][thislocal_0+1+0];
  float Res = ((1.0f/((((1.1f+((U_0_0*rsqrtf(((9.9999999E-9f+((U_0_p1-U_0_0)*(U_0_p1-U_0_0)))+((U_p1_0-U_0_0)*(U_p1_0-U_0_0)))))/V_0_0))+((U_0_0*rsqrtf(((9.9999999E-9f+((U_0_0-U_0_m1)*(U_0_0-U_0_m1)))+((U_p1_m1-U_0_m1)*(U_p1_m1-U_0_m1)))))/V_0_0))+((U_0_0*rsqrtf(((9.9999999E-9f+((U_0_p1-U_0_0)*(U_0_p1-U_0_0)))+((U_p1_0-U_0_0)*(U_p1_0-U_0_0)))))/V_0_0))+((U_0_0*rsqrtf(((9.9999999E-9f+((U_m1_p1-U_m1_0)*(U_m1_p1-U_m1_0)))+((U_0_0-U_m1_0)*(U_0_0-U_m1_0)))))/V_0_0)))*(((((1.1f*F_0_0)+(((U_0_0*rsqrtf(((9.9999999E-9f+((U_0_p1-U_0_0)*(U_0_p1-U_0_0)))+((U_p1_0-U_0_0)*(U_p1_0-U_0_0)))))/V_0_0)*U_0_p1))+(((U_0_0*rsqrtf(((9.9999999E-9f+((U_0_0-U_0_m1)*(U_0_0-U_0_m1)))+((U_p1_m1-U_0_m1)*(U_p1_m1-U_0_m1)))))/V_0_0)*U_0_m1))+(((U_0_0*rsqrtf(((9.9999999E-9f+((U_0_p1-U_0_0)*(U_0_p1-U_0_0)))+((U_p1_0-U_0_0)*(U_p1_0-U_0_0)))))/V_0_0)*U_p1_0))+(((U_0_0*rsqrtf(((9.9999999E-9f+((U_m1_p1-U_m1_0)*(U_m1_p1-U_m1_0)))+((U_0_0-U_m1_0)*(U_0_0-U_m1_0)))))/V_0_0)*U_m1_0)));
    Buffer_U[elem_1][elem_0] = Res;
  }
  }
}
 __syncthreads();
  for (unsigned elem_0 = 0; elem_0 < ts_0; ++elem_0) {
  int thisid_0 = tid_0 + elem_0*blockDim.x;
  int thislocal_0 = local_0 + elem_0*blockDim.x;
  for (unsigned elem_1 = 0; elem_1 < ts_1; ++elem_1) {
  int thisid_1 = tid_1 + elem_1;
  int thislocal_1 = threadIdx.y*ts_1 + elem_1;
    if ((thisid_0 >= 1 && thisid_0 < Dim_0 - 1) && (thisid_1 >= 1 && thisid_1 < Dim_1 - 1)) {
Shared_U[thislocal_1+1][thislocal_0+1] = Buffer_U[elem_1][elem_0];
    }
  }
  }
 __syncthreads();
  }
  for (unsigned elem_0 = 0; elem_0 < ts_0; ++elem_0) {
  int thisid_0 = tid_0 + elem_0*blockDim.x;
  int thislocal_0 = local_0 + elem_0*blockDim.x;
  for (unsigned elem_1 = 0; elem_1 < ts_1; ++elem_1) {
  int thisid_1 = tid_1 + elem_1;
  int thislocal_1 = threadIdx.y*ts_1 + elem_1;
      if ((thislocal_0 >= Halo_Left_0 && thislocal_0 < blockDim.x*ts_0 - Halo_Right_0 && thisid_0 >= 0 && thisid_0 < Dim_0 - 0) && (thislocal_1 >= Halo_Left_1 && thislocal_1 < blockDim.y*ts_1 - Halo_Right_1 && thisid_1 >= 0 && thisid_1 < Dim_1 - 0)) {
AddrOffset = thisid_0 + thisid_1*Dim_0;
*(Out_F + AddrOffset) = Buffer_F[elem_1][elem_0];
      }
  }
  }
  for (unsigned elem_0 = 0; elem_0 < ts_0; ++elem_0) {
  int thisid_0 = tid_0 + elem_0*blockDim.x;
  int thislocal_0 = local_0 + elem_0*blockDim.x;
  for (unsigned elem_1 = 0; elem_1 < ts_1; ++elem_1) {
  int thisid_1 = tid_1 + elem_1;
  int thislocal_1 = threadIdx.y*ts_1 + elem_1;
      if ((thislocal_0 >= Halo_Left_0 && thislocal_0 < blockDim.x*ts_0 - Halo_Right_0 && thisid_0 >= 0 && thisid_0 < Dim_0 - 0) && (thislocal_1 >= Halo_Left_1 && thislocal_1 < blockDim.y*ts_1 - Halo_Right_1 && thisid_1 >= 0 && thisid_1 < Dim_1 - 0)) {
AddrOffset = thisid_0 + thisid_1*Dim_0;
*(Out_V + AddrOffset) = Buffer_V[elem_1][elem_0];
      }
  }
  }
  for (unsigned elem_0 = 0; elem_0 < ts_0; ++elem_0) {
  int thisid_0 = tid_0 + elem_0*blockDim.x;
  int thislocal_0 = local_0 + elem_0*blockDim.x;
  for (unsigned elem_1 = 0; elem_1 < ts_1; ++elem_1) {
  int thisid_1 = tid_1 + elem_1;
  int thislocal_1 = threadIdx.y*ts_1 + elem_1;
      if ((thislocal_0 >= Halo_Left_0 && thislocal_0 < blockDim.x*ts_0 - Halo_Right_0 && thisid_0 >= 1 && thisid_0 < Dim_0 - 1) && (thislocal_1 >= Halo_Left_1 && thislocal_1 < blockDim.y*ts_1 - Halo_Right_1 && thisid_1 >= 1 && thisid_1 < Dim_1 - 1)) {
AddrOffset = thisid_0 + thisid_1*Dim_0;
*(Out_U + AddrOffset) = Buffer_U[elem_1][elem_0];
      }
  }
  }
} // End of kernel




//
// Generated by OverTile
//
// Description:
// CUDA host code
//
#include <iostream>
#include <algorithm>
#include <cassert>
void ot_program_tv2d(int timesteps, float *Host_U, float *Host_V, float *Host_F, int Dim_0, int Dim_1) {
  cudaError_t Result;
  int ArraySize = Dim_0*Dim_1;
  cudaEvent_t TotalStartEvent, TotalStopEvent;
  cudaEventCreate(&TotalStartEvent);
  cudaEventCreate(&TotalStopEvent);
  cudaEventRecord(TotalStartEvent, 0);
  float *deviceU_In;
  float *deviceU_Out;
  Result = cudaMalloc(&deviceU_In, sizeof(float)*ArraySize);
  assert(Result == cudaSuccess);
  Result = cudaMalloc(&deviceU_Out, sizeof(float)*ArraySize);
  assert(Result == cudaSuccess);
  float *deviceU_InPtr = deviceU_In;
  float *deviceU_OutPtr = deviceU_Out;
  Result = cudaMemcpy(deviceU_In, Host_U, sizeof(float)*ArraySize, cudaMemcpyHostToDevice);
  assert(Result == cudaSuccess);
  Result = cudaMemcpy(deviceU_Out, deviceU_In, sizeof(float)*ArraySize, cudaMemcpyDeviceToDevice);
  assert(Result == cudaSuccess);
  float *deviceV_In;
  float *deviceV_Out;
  Result = cudaMalloc(&deviceV_In, sizeof(float)*ArraySize);
  assert(Result == cudaSuccess);
  Result = cudaMalloc(&deviceV_Out, sizeof(float)*ArraySize);
  assert(Result == cudaSuccess);
  float *deviceV_InPtr = deviceV_In;
  float *deviceV_OutPtr = deviceV_Out;
  Result = cudaMemcpy(deviceV_In, Host_V, sizeof(float)*ArraySize, cudaMemcpyHostToDevice);
  assert(Result == cudaSuccess);
  Result = cudaMemcpy(deviceV_Out, deviceV_In, sizeof(float)*ArraySize, cudaMemcpyDeviceToDevice);
  assert(Result == cudaSuccess);
  float *deviceF_In;
  float *deviceF_Out;
  Result = cudaMalloc(&deviceF_In, sizeof(float)*ArraySize);
  assert(Result == cudaSuccess);
  Result = cudaMalloc(&deviceF_Out, sizeof(float)*ArraySize);
  assert(Result == cudaSuccess);
  float *deviceF_InPtr = deviceF_In;
  float *deviceF_OutPtr = deviceF_Out;
  Result = cudaMemcpy(deviceF_In, Host_F, sizeof(float)*ArraySize, cudaMemcpyHostToDevice);
  assert(Result == cudaSuccess);
  Result = cudaMemcpy(deviceF_Out, deviceF_In, sizeof(float)*ArraySize, cudaMemcpyDeviceToDevice);
  assert(Result == cudaSuccess);
  const int Halo_Left_0 = 0;
  const int Halo_Right_0 = 0;
  const int real_per_block_0 = 64 - Halo_Left_0 - Halo_Right_0;
  const int Halo_Left_1 = 0;
  const int Halo_Right_1 = 0;
  const int real_per_block_1 = 32 - Halo_Left_1 - Halo_Right_1;
  dim3 block_size(64, 8);
  int num_blocks_0 = Dim_0 / real_per_block_0;
  int extra_0 = Dim_0 % real_per_block_0;
  num_blocks_0 = num_blocks_0 + (extra_0 > 0 ? 1 : 0);
  int num_blocks_1 = Dim_1 / real_per_block_1;
  int extra_1 = Dim_1 % real_per_block_1;
  num_blocks_1 = num_blocks_1 + (extra_1 > 0 ? 1 : 0);
  dim3 grid_size(num_blocks_0, num_blocks_1);
  cudaThreadSynchronize();
  cudaEvent_t StartEvent, StopEvent;
  cudaEventCreate(&StartEvent);
  cudaEventCreate(&StopEvent);
  cudaEventRecord(StartEvent, 0);
  for (int t = 0; t < timesteps; t += 1) {
    ot_kernel_tv2d<<<grid_size, block_size>>>(deviceU_InPtr, deviceU_OutPtr, deviceV_InPtr, deviceV_OutPtr, deviceF_InPtr, deviceF_OutPtr, Dim_0, Dim_1);
    std::swap(deviceU_InPtr, deviceU_OutPtr);
    std::swap(deviceV_InPtr, deviceV_OutPtr);
    std::swap(deviceF_InPtr, deviceF_OutPtr);
  }
  assert(cudaEventRecord(StopEvent, 0) == cudaSuccess);
  assert(cudaEventSynchronize(StopEvent) == cudaSuccess);
  Result = cudaMemcpy(Host_U, deviceU_InPtr, sizeof(float)*ArraySize, cudaMemcpyDeviceToHost);
  assert(Result == cudaSuccess);
  Result = cudaMemcpy(Host_V, deviceV_InPtr, sizeof(float)*ArraySize, cudaMemcpyDeviceToHost);
  assert(Result == cudaSuccess);
  Result = cudaMemcpy(Host_F, deviceF_InPtr, sizeof(float)*ArraySize, cudaMemcpyDeviceToHost);
  assert(Result == cudaSuccess);
  cudaEventRecord(TotalStopEvent, 0);
  assert(cudaEventSynchronize(TotalStopEvent) == cudaSuccess);
  double Flops = 0.0;
  double Points;
  Points = (Dim_0-0) * (Dim_1-0);
  Flops = Flops + Points * 0.000000e+00;
  Points = (Dim_0-0) * (Dim_1-0);
  Flops = Flops + Points * 0.000000e+00;
  Points = (Dim_0-2) * (Dim_1-2);
  Flops = Flops + Points * 1.030000e+02;
  Flops = Flops * timesteps;
  float ElapsedMS;
  cudaEventElapsedTime(&ElapsedMS, StartEvent, StopEvent);
  double Elapsed = ElapsedMS / 1000.0;
  double GFlops = Flops / Elapsed / 1e9;
  std::cerr << "GFlops: " << GFlops << "\n";
  std::cerr << "Elapsed: " << Elapsed << "\n";
  float TotalElapsedMS;
  cudaEventElapsedTime(&TotalElapsedMS, TotalStartEvent, TotalStopEvent);
  double TotalElapsed = TotalElapsedMS / 1000.0;
  double TotalGFlops = Flops / TotalElapsed / 1e9;
  std::cerr << "Total GFlops: " << TotalGFlops << "\n";
  std::cerr << "Total Elapsed: " << TotalElapsed << "\n";
  cudaEventDestroy(StartEvent);
  cudaEventDestroy(StopEvent);
  cudaEventDestroy(TotalStartEvent);
  cudaEventDestroy(TotalStopEvent);
  cudaFree(deviceU_In);
  cudaFree(deviceU_Out);
  cudaFree(deviceV_In);
  cudaFree(deviceV_Out);
  cudaFree(deviceF_In);
  cudaFree(deviceF_Out);
}
